import React, { createContext, useState, useContext, useRef, useEffect, Component } from 'react';
import _$1 from 'lodash';
import { getLatestChats as getLatestChats$1, getLatestMessages as getLatestMessages$1, readMessage as readMessage$1, TextInput as TextInput$1, Button as Button$1, newChat as newChat$1, Avatar as Avatar$1, removePerson as removePerson$1, AutoCompleteInput, addPerson as addPerson$1, getOtherPeople as getOtherPeople$1, deleteChat as deleteChat$1, editChat as editChat$1, Dot as Dot$1, isTyping as isTyping$1, sendMessage as sendMessage$1, getChat as getChat$1 } from 'react-chat-engine';
import { WebSocket } from 'nextjs-websocket';
import axios from 'axios';
import { SyncOutlined, MenuOutlined, CloseOutlined, LeftOutlined, DownOutlined, SettingOutlined, LoadingOutlined, CloseCircleTwoTone, PaperClipOutlined, PlusOutlined, ArrowUpOutlined, DeleteOutlined, UserAddOutlined } from '@ant-design/icons';
import { setConfiguration, Row, Col } from 'react-grid-system';
import { animateScroll } from 'react-scroll';

var ChatEngineContext = createContext();
var ChatEngineWrapper = function ChatEngineWrapper(props) {
  var _useState = useState(true),
      connecting = _useState[0],
      setConnecting = _useState[1];

  var _useState2 = useState(null),
      conn = _useState2[0],
      setConn = _useState2[1];

  var _useState3 = useState(null),
      creds = _useState3[0],
      setCreds = _useState3[1];

  var _useState4 = useState(null),
      chats = _useState4[0],
      setChats = _useState4[1];

  var _useState5 = useState({}),
      messages = _useState5[0],
      setMessages = _useState5[1];

  var _useState6 = useState({}),
      sendingMessages = _useState6[0],
      setSendingMessages = _useState6[1];

  var _useState7 = useState(null),
      activeChat = _useState7[0],
      setActiveChat = _useState7[1];

  var _useState8 = useState({}),
      typingCounter = _useState8[0],
      setTypingCounter = _useState8[1];

  var _useState9 = useState(false),
      loadMoreMessages = _useState9[0],
      setLoadMoreMessages = _useState9[1];

  var _useState10 = useState(false),
      isBottomVisible = _useState10[0],
      setIsBottomVisible = _useState10[1];

  var value = {
    connecting: connecting,
    setConnecting: setConnecting,
    conn: conn,
    setConn: setConn,
    creds: creds,
    setCreds: setCreds,
    chats: chats,
    setChats: setChats,
    messages: messages,
    setMessages: setMessages,
    sendingMessages: sendingMessages,
    setSendingMessages: setSendingMessages,
    activeChat: activeChat,
    setActiveChat: setActiveChat,
    typingCounter: typingCounter,
    setTypingCounter: setTypingCounter,
    loadMoreMessages: loadMoreMessages,
    setLoadMoreMessages: setLoadMoreMessages,
    isBottomVisible: isBottomVisible,
    setIsBottomVisible: setIsBottomVisible
  };
  return /*#__PURE__*/React.createElement(ChatEngineContext.Provider, {
    value: value
  }, props.children);
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var _this = undefined;

var Socket = function Socket(props) {
  var _useState = useState(Date.now() + 10000),
      reconnect = _useState[0];

  var _useContext = useContext(ChatEngineContext),
      setConnecting = _useContext.setConnecting,
      conn = _useContext.conn,
      setConn = _useContext.setConn,
      setCreds = _useContext.setCreds,
      chats = _useContext.chats,
      setChats = _useContext.setChats,
      messages = _useContext.messages,
      setMessages = _useContext.setMessages,
      sendingMessages = _useContext.sendingMessages,
      setSendingMessages = _useContext.setSendingMessages,
      activeChat = _useContext.activeChat,
      setActiveChat = _useContext.setActiveChat,
      typingCounter = _useContext.typingCounter,
      setTypingCounter = _useContext.setTypingCounter;

  function sortChats(chats) {
    return Object.values(chats).sort(function (a, b) {
      var aDate = a.last_message.created ? new Date(a.last_message.created) : new Date(a.created);
      var bDate = b.last_message.created ? new Date(b.last_message.created) : new Date(b.created);
      return new Date(bDate) - new Date(aDate);
    });
  }

  function onEditChat(chat) {
    if (chats) {
      var newChats = _extends({}, chats);

      newChats[chat.id] = chat;
      setChats(newChats);
    }

    props.onEditChat && props.onEditChat(chat);
  }

  function onConnect(conn) {
    setConn(conn);
    setCreds(conn);
    setConnecting(false);
    getLatestChats$1(conn, 25, function (chats) {
      return setChats(_.mapKeys(chats, 'id'));
    });

    if (Date.now() > reconnect) {
      getLatestMessages$1(conn, activeChat, 45, function (id, list) {
        setMessages(_extends({}, messages, _.mapKeys(list, 'id')));
      });
    }

    props.onConnect && props.onConnect(conn);
  }

  function handleEvent(event) {
    var eventJSON = JSON.parse(event);

    if (eventJSON.action === 'login_error') {
      console.log("Your login credentials were not correct: \n\n                Project ID: " + props.projectID + " \n\n                Username: " + props.userName + " \n\n                User Secret: " + props.userSecret + "\n\n                Double check these credentials to make sure they're correct.\n\n                If all three are correct, try resetting the username and secret in the Online Dashboard or Private API.");
      setConn(undefined);
      setCreds(undefined);
      props.onFailAuth && props.onFailAuth(conn);
    } else if (eventJSON.action === 'new_chat') {
      var chat = eventJSON.data;

      if (chats) {
        var newChats = _extends({}, chats);

        newChats[chat.id] = chat;
        setChats(newChats);
        setActiveChat(chat.id);
      }

      props.onNewChat && props.onNewChat(eventJSON.data);
    } else if (eventJSON.action === 'edit_chat') {
      onEditChat(eventJSON.data);
    } else if (eventJSON.action === 'delete_chat') {
      var _chat = eventJSON.data;

      if (chats) {
        chats[_chat.id] = undefined;
        setChats(chats);

        if (!_.isEmpty(chats)) {
          var sortedChats = sortChats(chats);
          setActiveChat(sortedChats[0] ? parseInt(sortedChats[0].id) : 0);
        }
      }

      props.onDeleteChat && props.onDeleteChat(_chat);
    } else if (eventJSON.action === 'add_person') {
      onEditChat(eventJSON.data);
      props.onAddPerson && props.onAddPerson(eventJSON.data);
    } else if (eventJSON.action === 'remove_person') {
      onEditChat(eventJSON.data);
      props.onRemovePerson && props.onRemovePerson(eventJSON.data);
    } else if (eventJSON.action === 'new_message') {
      var _eventJSON$data = eventJSON.data,
          id = _eventJSON$data.id,
          message = _eventJSON$data.message;

      if (typeof message.custom_json === "string" && message.custom_json.indexOf('sender_id') !== -1) {
        sendingMessages[JSON.parse(message.custom_json).sender_id] = undefined;
        setSendingMessages(sendingMessages);
      }

      if (id === activeChat) {
        var newMessages = _extends({}, messages);

        newMessages[message.id] = message;
        setMessages(newMessages);
      }

      if (message.sender_username !== props.userName) {
        readMessage$1(conn, activeChat, message.id, function (chat) {
          return onEditChat(chat);
        });
      }

      props.onNewMessage && props.onNewMessage(id, message);
    } else if (eventJSON.action === 'edit_message') {
      var _eventJSON$data2 = eventJSON.data,
          _id = _eventJSON$data2.id,
          _message = _eventJSON$data2.message;

      if (_id === activeChat) {
        messages[_message.id] = _message;
        setMessages(messages);
      }

      props.onEditMessage && props.onEditMessage(_id, _message);
    } else if (eventJSON.action === 'delete_message') {
      var _eventJSON$data3 = eventJSON.data,
          _id2 = _eventJSON$data3.id,
          _message2 = _eventJSON$data3.message;

      if (_id2 === activeChat) {
        messages[_message2.id] = undefined;
        setMessages(messages);
      }

      props.onDeleteMessage && props.onDeleteMessage(_id2, _message2);
    } else if (eventJSON.action === 'is_typing') {
      var _extends2, _extends3;

      var _eventJSON$data4 = eventJSON.data,
          _id3 = _eventJSON$data4.id,
          person = _eventJSON$data4.person;

      var newTypingCounter = _extends({}, typingCounter);

      newTypingCounter = _extends({}, newTypingCounter, (_extends3 = {}, _extends3[_id3] = _extends({}, newTypingCounter[_id3], (_extends2 = {}, _extends2[person] = Date.now(), _extends2)), _extends3));
      setTypingCounter(newTypingCounter);
      props.onTyping && props.onTyping(_id3, person);
    }
  }

  function onClose() {
    setConnecting(true);
  }

  var development = props.development,
      publicKey = props.publicKey,
      projectID = props.projectID,
      userName = props.userName,
      userPassword = props.userPassword,
      userSecret = props.userSecret;
  var wsStart = development ? 'ws://' : 'wss://';
  var rootHost = development ? '127.0.0.1:8000' : 'api.chatengine.io';
  var project = publicKey ? publicKey : projectID;
  var secret = userPassword ? userPassword : userSecret;
  return /*#__PURE__*/React.createElement(WebSocket, {
    url: "" + wsStart + rootHost + "/person/?publicKey=" + project + "&username=" + userName + "&secret=" + secret,
    onOpen: function onOpen() {
      return onConnect(props);
    },
    onClose: onClose.bind(_this),
    onMessage: handleEvent.bind(_this),
    reconnectIntervalInMilliSeconds: 3000
  });
};

function getApiUrl(props) {
  if (props && props.development) {
    return 'http://127.0.0.1:8000';
  }

  return 'https://api.chatengine.io';
}

function getHeaders(props) {
  if (props.chatID) {
    return {
      "public-key": props.publicKey ? props.publicKey : props.projectID,
      "chat-id": props.chatID,
      "access-key": props.chatAccessKey
    };
  }

  return {
    "Public-Key": props.publicKey ? props.publicKey : props.projectID,
    "User-Name": props.userName,
    "User-Secret": props.userPassword ? props.userPassword : props.userSecret
  };
}

function getChats(props, callback) {
  axios.get(getApiUrl(props) + "/chats/", {
    headers: getHeaders(props)
  }).then(function (response) {
    props.onGetChats && props.onGetChats(response.data);
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Fetch Chats Error', error);
  });
}

function newChat(props, data, callback) {
  axios.post(getApiUrl(props) + "/chats/", data, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('New Chat Error', error);
  });
}

function getLatestChats(props, count, callback) {
  axios.get(getApiUrl(props) + "/chats/latest/" + count + "/", {
    headers: getHeaders(props)
  }).then(function (response) {
    props.onGetChats && props.onGetChats(response.data);
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Fetch Chats Error', error);
  });
}

function getOrCreateChat(props, data, callback) {
  axios.put(getApiUrl(props) + "/chats/", data, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Get or Create Chat Error', error);
  });
}

function getChat(props, chatId, callback) {
  axios.get(getApiUrl(props) + "/chats/" + chatId + "/", {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Get Chat Error', error);
  });
}

function editChat(props, chatId, data, callback) {
  axios.patch(getApiUrl(props) + "/chats/" + chatId + "/", data, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Edit Chat Error', error);
  });
}

function deleteChat(props, chatId, callback) {
  axios["delete"](getApiUrl(props) + "/chats/" + chatId + "/", {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Delete Chat Error', error);
  });
}

var ChatLoader = function ChatLoader(props) {
  function useOnScreen(ref) {
    var _useState = useState(false),
        isIntersecting = _useState[0],
        setIntersecting = _useState[1];

    var observer = new IntersectionObserver(function (_ref) {
      var entry = _ref[0];
      setIntersecting(entry.isIntersecting);

      if (entry.isIntersecting) {
        props.onVisible();
      }
    });
    useEffect(function () {
      observer.observe(ref.current);
      return function () {
        observer.disconnect();
      };
    }, []);
    return isIntersecting;
  }

  var ref = useRef();
  var isVisible = useOnScreen(ref);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  });
};

var _this$1 = undefined;

var NewChatForm = function NewChatForm() {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn;

  var _useState = useState(''),
      value = _useState[0],
      setValue = _useState[1];

  var _useState2 = useState(false),
      selected = _useState2[0],
      setSelected = _useState2[1];

  function _handleChange(event) {
    setValue(event.target.value);
  }

  function handleSubmit(event) {
    event.preventDefault();

    if (value.trim().length > 0) {
      newChat$1(conn, {
        title: value
      }, function () {
        return setSelected(false);
      });
    }

    setValue('');
  }

  return /*#__PURE__*/React.createElement("div", {
    style: styles.newChatContainer,
    className: "ce-chat-form-container"
  }, selected ? /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit.bind(_this$1)
  }, /*#__PURE__*/React.createElement(TextInput$1, {
    autoFocus: true,
    label: "Chat Title",
    value: value,
    id: "ce-new-chat-title-field",
    onBlur: function onBlur() {
      return setSelected(false);
    },
    style: {
      width: '100%'
    },
    handleChange: function handleChange(e) {
      return _handleChange(e);
    }
  })) : /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    style: {
      height: '0px'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontWeight: '600',
      fontSize: '24px',
      position: 'relative',
      top: '4px',
      width: ' calc(100% - 48px)'
    }
  }, "My Chats")), /*#__PURE__*/React.createElement("div", {
    style: {
      width: '100%',
      textAlign: 'right'
    }
  }, /*#__PURE__*/React.createElement(Button$1, {
    icon: "plus",
    id: "new-chat-plus-button",
    onClick: function onClick() {
      return setSelected(true);
    }
  }))));
};
var styles = {
  newChatContainer: {
    padding: '16px 14px',
    backgroundColor: 'white'
  }
};

function timeSinceDate(date) {
  if (!date) return '';
  var day = date.substr(8, 2);
  var month = date.substr(5, 2);
  var year = date.substr(0, 4);
  var hour = date.substr(11, 2);
  var minute = date.substr(14, 2);
  var second = date.substr(17, 2);
  var sent = new Date(month + " " + day + " " + year);
  sent.setHours(hour);
  sent.setMinutes(minute);
  sent.setSeconds(second);
  sent = sent.toString();
  var dayStr = sent.substr(0, 10);
  var timeStr = sent.substr(15, 6);
  return dayStr + " at " + timeStr;
}
function daySinceSent(date) {
  if (!date) return '';
  var day = date.substr(8, 2);
  var month = date.substr(5, 2);
  var year = date.substr(0, 4);
  var sent = new Date(month + " " + day + " " + year).toString();
  return sent.substr(4, 6);
}

var ChatCard = function ChatCard(props) {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      activeChat = _useContext.activeChat,
      setActiveChat = _useContext.setActiveChat;

  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);

  function readLastMessage(chat) {
    var readLastMessage = true;
    chat.people.map(function (chat_person) {
      if (conn.userName === chat_person.person.username) {
        readLastMessage = chat.last_message.id === chat_person.last_read;
      }
    });
    return readLastMessage;
  }

  var chat = props.chat;
  var extraStyle = activeChat === chat.id ? styles$1.activeChat : {};
  var otherPerson = chat.people.find(function (person) {
    return person.person.username !== conn.userName;
  });
  var title = chat.is_direct_chat && otherPerson ? otherPerson.person.username : chat.title;
  var lastMessage = chat.last_message.text;

  if (!lastMessage) {
    lastMessage = chat.last_message.attachments.length > 0 ? chat.last_message.attachments.length + " image" + (chat.last_message.attachments.length > 1 ? 's' : '') : 'Say hello!';
  }

  return /*#__PURE__*/React.createElement("div", {
    onClick: function onClick() {
      return setActiveChat(chat.id);
    },
    style: _extends({}, styles$1.chatContainer, extraStyle),
    className: "ce-chat-card " + (activeChat === chat.id && 'ce-active-chat-card')
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$1.titleText,
    className: "ce-chat-title-text",
    id: "ce-chat-card-title-" + title
  }, title, !readLastMessage(chat) && /*#__PURE__*/React.createElement("div", {
    className: "ce-chat-unread-dot",
    style: {
      "float": 'right',
      width: '12px',
      height: '12px',
      borderRadius: '6px',
      backgroundColor: '#1890ff',
      display: 'inline-block'
    }
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      width: '100%'
    },
    className: "ce-chat-subtitle"
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$1.messageText,
    className: "ce-chat-subtitle-text ce-chat-subtitle-message"
  }, lastMessage), /*#__PURE__*/React.createElement("div", {
    className: "ce-chat-subtitle-text ce-chat-subtitle-date",
    style: _extends({}, styles$1.messageText, {
      textAlign: 'right',
      width: '25%'
    })
  }, daySinceSent(chat.last_message.created))));
};

var styles$1 = {
  chatContainer: {
    padding: '16px',
    paddingBottom: '12px',
    cursor: 'pointer'
  },
  titleText: {
    fontWeight: '500',
    paddingBottom: '4px',
    whiteSpace: 'nowrap',
    overflow: 'hidden'
  },
  messageText: {
    width: '75%',
    color: 'rgba(153, 153, 153, 1)',
    fontSize: '14px',
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    display: 'inline-block'
  },
  activeChat: {
    backgroundColor: '#d9d9d9',
    border: '4px solid white',
    borderRadius: '12px'
  }
};

var count = 25;
var interval = 25;

var ChatList = function ChatList(props) {
  var didMountRef = useRef(false);

  var _useState = useState(true),
      hasMoreChats = _useState[0],
      setHasMoreChats = _useState[1];

  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      chats = _useContext.chats,
      setChats = _useContext.setChats,
      activeChat = _useContext.activeChat,
      setActiveChat = _useContext.setActiveChat;

  function renderChats(chats) {
    return chats.map(function (chat, index) {
      if (!chat) {
        return /*#__PURE__*/React.createElement("div", {
          key: "chat_" + index
        });
      } else if (props.renderChatCard) {
        return /*#__PURE__*/React.createElement("div", {
          key: "chat_" + index
        }, props.renderChatCard(chat, index));
      } else {
        return /*#__PURE__*/React.createElement("div", {
          key: "chat_" + index,
          onClick: function onClick() {
            return props.onChatClick && props.onChatClick();
          }
        }, /*#__PURE__*/React.createElement(ChatCard, {
          chat: chat
        }));
      }
    });
  }

  function sortChats(chats) {
    return chats.sort(function (a, b) {
      var aDate = a.last_message.created ? new Date(a.last_message.created) : new Date(a.created);
      var bDate = b.last_message.created ? new Date(b.last_message.created) : new Date(b.created);
      return new Date(bDate) - new Date(aDate);
    });
  }

  function onGetChats(chats, count) {
    var chatList = sortChats(chats);

    if (chatList.length > 0 && activeChat === null) {
      setActiveChat(chatList[0].id);
    }

    if (count && count > chatList.length) {
      setHasMoreChats(false);
    }

    var newChats = _extends({}, chats);

    setChats(_$1.mapKeys(newChats, 'id'));
  }

  useEffect(function () {
    if (!didMountRef.current) {
      didMountRef.current = true;
      getLatestChats(props, interval, function (chats) {
        return onGetChats(chats);
      });
    }
  });

  function loadChats() {
    count = count + interval;
    getLatestChats(props, count, function (chats) {
      return onGetChats(chats, count);
    });
  }

  var chatList = sortChats(chats ? Object.values(chats) : []);
  if (props.renderChatList) return props.renderChatList(props);
  return /*#__PURE__*/React.createElement("div", {
    style: styles$2.chatListContainer,
    className: "ce-chat-list"
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$2.chatsContainer,
    className: "ce-chats-container"
  }, props.renderNewChatForm ? props.renderNewChatForm(conn) : /*#__PURE__*/React.createElement(NewChatForm, null), renderChats(chatList), hasMoreChats && chatList.length > 0 && /*#__PURE__*/React.createElement(ChatLoader, {
    onVisible: function onVisible() {
      return loadChats();
    }
  })));
};

var styles$2 = {
  chatListContainer: {
    height: '100%',
    maxHeight: '100vh',
    overflow: 'scroll',
    overflowX: 'hidden',
    borderRight: '1px solid #afafaf',
    backgroundColor: 'white',
    fontFamily: 'Avenir'
  },
  chatsContainer: {
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
    borderRadius: '0px 0px 24px 24px'
  }
};

function getMessages(props, chatId, callback) {
  axios.get(getApiUrl(props) + "/chats/" + chatId + "/messages/", {
    headers: getHeaders(props)
  }).then(function (response) {
    props.onGetMessages && props.onGetMessages(chatId, response.data);
    callback && callback(chatId, response.data);
  })["catch"](function (error) {
    console.log('Fetch Messages Error', error);
  });
}

function getLatestMessages(props, chatId, count, callback) {
  axios.get(getApiUrl(props) + "/chats/" + chatId + "/messages/latest/" + count + "/", {
    headers: getHeaders(props)
  }).then(function (response) {
    props.onGetMessages && props.onGetMessages(chatId, response.data);
    callback && callback(chatId, response.data);
  })["catch"](function (error) {
    console.log('Fetch Latest Messages Error', error);
  });
}

function sendMessage(props, chatId, data, callback) {
  var formdata = new FormData();

  if (data.attachments) {
    for (var i = 0; i < data.attachments.length; i++) {
      formdata.append('attachments', data.attachments[i], data.attachments[i].name);
    }
  } else if (data.files) {
    for (var _i = 0; _i < data.files.length; _i++) {
      formdata.append('attachments', data.files[_i], data.files[_i].name);
    }
  }

  formdata.append('text', data.text);
  formdata.append('sender_username', data.sender_username);
  formdata.append('custom_json', JSON.stringify(data.custom_json ? data.custom_json : {}));
  axios.post(getApiUrl(props) + "/chats/" + chatId + "/messages/", formdata, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Send Messages Error', error);
  });
}

function getMessage(props, chatId, messageId, callback) {
  axios.get(getApiUrl(props) + "/chats/" + chatId + "/messages/" + messageId + "/", {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(chatId, response.data);
  })["catch"](function (error) {
    console.log('Fetch Message Error', error);
  });
}

function editMessage(props, chatId, messageId, data, callback) {
  axios.patch(getApiUrl(props) + "/chats/" + chatId + "/messages/" + messageId + "/", data, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Delete Messages Error', error);
  });
}

function readMessage(props, chatId, messageId, callback) {
  axios.patch(getApiUrl(props) + "/chats/" + chatId + "/people/", {
    last_read: messageId
  }, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Read Message Error', error);
  });
}

function deleteMessage(props, chatId, messageId, callback) {
  axios["delete"](getApiUrl(props) + "/chats/" + chatId + "/messages/" + messageId + "/", {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Delete Messages Error', error);
  });
}

var AuthFail = function AuthFail() {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      height: '100%',
      textAlign: 'center'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      width: '100%'
    }
  }, /*#__PURE__*/React.createElement("img", {
    style: {
      width: '40%',
      paddingTop: '25vh'
    },
    src: "https://chat-engine-assets.s3.amazonaws.com/denied.svg",
    alt: "welcome-to-chat-engine"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '18px',
      paddingTop: '24px',
      width: '75%',
      paddingLeft: '12.5%'
    }
  }, "Your credentials are incorrect. Make sure your Public Key, Username, and Password are correct at ", /*#__PURE__*/React.createElement("a", {
    href: "https://chatengine.io"
  }, "chatengine.io")));
};

var Welcome = function Welcome() {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      height: '100%',
      textAlign: 'center'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      width: '100%'
    }
  }, /*#__PURE__*/React.createElement("img", {
    style: {
      width: '60%',
      paddingTop: '33vh'
    },
    src: "https://chat-engine-assets.s3.amazonaws.com/welcome.svg",
    alt: "welcome-to-chat-engine"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '18px',
      paddingTop: '24px',
      width: '75%',
      paddingLeft: '12.5%'
    }
  }, "Fill out the \"New Chat\" form to get started."));
};

var ConnectionBar = function ConnectionBar() {
  var _useContext = useContext(ChatEngineContext),
      connecting = _useContext.connecting;

  if (!connecting) return /*#__PURE__*/React.createElement("div", null);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      zIndex: '1',
      bottom: '66px',
      left: 'calc(50% - 78px)',
      position: 'absolute',
      fontSize: '15px',
      padding: '10px 22px',
      color: 'white',
      backgroundColor: '#fa8c16',
      borderRadius: '1.3em'
    },
    id: "ce-connecting-popup"
  }, /*#__PURE__*/React.createElement(SyncOutlined, {
    spin: true
  }), ' ', "Connecting");
};

var ChatListDrawer = function ChatListDrawer(props) {
  var _useState = useState(false),
      isOpen = _useState[0],
      setIsOpen = _useState[1];

  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(MenuOutlined, {
    onClick: function onClick() {
      return setIsOpen(true);
    },
    style: {
      color: 'rgb(24, 144, 255)',
      outline: 'none'
    }
  }), isOpen && /*#__PURE__*/React.createElement("div", {
    style: styles$3.drawerContainer
  }, /*#__PURE__*/React.createElement(CloseOutlined, {
    style: styles$3.closeIcon,
    onClick: function onClick() {
      return setIsOpen(false);
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: styles$3.titleContainer
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$3.titleText
  }, "My Chats")), /*#__PURE__*/React.createElement(ChatList, _extends({}, props, {
    onChatClick: function onChatClick() {
      return setIsOpen(false);
    }
  }))));
};
var styles$3 = {
  drawerContainer: {
    position: 'fixed',
    zIndex: '1',
    top: '0px',
    left: '0px',
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
    textAlign: 'left'
  },
  closeIcon: {
    position: 'absolute',
    left: '28px',
    top: '32px'
  },
  titleContainer: {
    width: '100%',
    padding: '24px 0px',
    textAlign: 'center',
    color: 'rgb(24, 144, 255)'
  },
  titleText: {
    fontSize: '24px',
    fontWeight: '600'
  }
};

var Person = function Person(props) {
  var _useState = useState(false),
      selected = _useState[0],
      setSelected = _useState[1];

  var person = props.person,
      chat = props.chat,
      conn = props.conn;

  if (!person || !chat) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);

  function onRemovePerson() {
    removePerson$1(props.conn, props.chat.id, props.person.username);
  }

  function renderPersonText(person) {
    if (person.first_name && person.first_name !== null) {
      return "" + person.first_name + (person.last_name ? " " + person.last_name : '');
    } else {
      return person.username;
    }
  }

  return /*#__PURE__*/React.createElement("div", {
    className: "ce-person-container",
    onMouseEnter: function onMouseEnter() {
      return setSelected(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setSelected(false);
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "ce-person-avatar",
    style: {
      padding: '2px',
      height: '0px'
    }
  }, /*#__PURE__*/React.createElement(Avatar$1, {
    avatar: person.avatar,
    username: person.username,
    is_online: person.is_online
  })), /*#__PURE__*/React.createElement("div", {
    className: "ce-person-text",
    style: {
      paddingLeft: '52px',
      height: '44px',
      position: 'relative',
      top: '10px',
      fontSize: '15px'
    }
  }, renderPersonText(person)), selected && conn.userName === chat.admin.username && person.username !== chat.admin.username && /*#__PURE__*/React.createElement("div", {
    className: "ce-delete-chat",
    style: {
      "float": 'right',
      height: '0px',
      position: 'relative',
      bottom: '44px'
    }
  }, /*#__PURE__*/React.createElement(Button$1, {
    theme: "danger",
    icon: "delete",
    onClick: function onClick() {
      return onRemovePerson();
    }
  })));
};

var Option = function Option(props) {
  var _useState = useState(false),
      focused = _useState[0],
      setFocused = _useState[1];

  var _props$person = props.person,
      avatar = _props$person.avatar,
      username = _props$person.username;
  return /*#__PURE__*/React.createElement("div", {
    id: "ce-username-option-" + username,
    onMouseEnter: function onMouseEnter() {
      return setFocused(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setFocused(false);
    },
    onClick: function onClick() {
      return props.onClick && props.onClick();
    },
    style: _extends({}, styles$4.option, {
      backgroundColor: focused ? '#f5f5f5' : 'white'
    })
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Avatar$1, {
    username: username,
    avatar: avatar
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      padding: '12px 4px'
    }
  }, props.person.username));
};
var styles$4 = {
  option: {
    padding: '4px 16px',
    cursor: 'pointer',
    fontSize: '15px',
    display: 'flex'
  }
};

var PersonForm = function PersonForm(props) {
  var _useState = useState({
    value: '',
    others: []
  }),
      state = _useState[0],
      setState = _useState[1];

  function _handleChange(value) {
    setState(_extends({}, state, {
      value: value
    }));
  }

  function invitePerson(name) {
    addPerson$1(props.conn, props.chat.id, name, function () {
      setState(_extends({}, state, {
        value: ''
      }));
      getOthers();
    });
  }

  function getOthers() {
    getOtherPeople$1(props.conn, props.chat.id, function (id, others) {
      return setState(_extends({}, state, {
        others: others
      }));
    }, function () {});
  }

  function _renderOption(option) {
    return /*#__PURE__*/React.createElement(Option, {
      person: option,
      onClick: function onClick() {
        return invitePerson(option.username);
      }
    });
  }

  return /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: '12px'
    }
  }, /*#__PURE__*/React.createElement(AutoCompleteInput, {
    style: {
      width: '100%'
    },
    label: "Type a username",
    value: state.value,
    options: state.others,
    onFocus: function onFocus() {
      return getOthers();
    },
    handleChange: function handleChange(value) {
      return _handleChange(value);
    },
    renderOption: function renderOption(option) {
      return _renderOption(option);
    }
  }));
};

var PeopleSettings = function PeopleSettings(props) {
  var _useState = useState({
    collapsed: false,
    hovered: false
  }),
      state = _useState[0],
      setState = _useState[1];

  var chat = props.chat;

  if (chat.is_direct_chat) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  function renderChatPeople(people, chat) {
    return people.map(function (chatPerson, index) {
      return /*#__PURE__*/React.createElement(Person, {
        key: "person_" + index,
        person: chatPerson.person,
        conn: props,
        chat: chat
      });
    });
  }

  return /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px solid #f0f0f0'
    }
  }, /*#__PURE__*/React.createElement("div", {
    onMouseEnter: function onMouseEnter() {
      return setState(_extends({}, state, {
        hovered: true
      }));
    },
    onMouseLeave: function onMouseLeave() {
      return setState(_extends({}, state, {
        hovered: false
      }));
    },
    onClick: function onClick() {
      return setState(_extends({}, state, {
        collapsed: !state.collapsed
      }));
    },
    style: state.hovered ? {
      backgroundColor: '#f0f0f0',
      cursor: 'pointer'
    } : {},
    className: "ce-section-title-container ce-person-title-container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "ce-section-title ce-people-title",
    style: {
      fontSize: '17px',
      padding: '12px',
      fontWeight: '600'
    }
  }, "People"), state.collapsed ? /*#__PURE__*/React.createElement(LeftOutlined, {
    style: styles$5.collapseIcon
  }) : /*#__PURE__*/React.createElement(DownOutlined, {
    style: styles$5.collapseIcon
  })), !state.collapsed && /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    style: {
      height: '12px'
    }
  }), renderChatPeople(chat.people, chat), /*#__PURE__*/React.createElement("div", {
    style: {
      height: '12px'
    }
  }), props && chat && props.userName === chat.admin.username && /*#__PURE__*/React.createElement(PersonForm, {
    conn: props,
    chat: chat
  })));
};
var styles$5 = {
  collapseIcon: {
    "float": 'right',
    position: 'relative',
    bottom: '30px',
    right: '12px'
  }
};

var Thumbnail = function Thumbnail(props) {
  var attachment = props.attachment;

  if (!attachment) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  return /*#__PURE__*/React.createElement("div", {
    style: styles$6.container,
    className: "ce-photo-thumbnail"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      paddingTop: '100%'
    }
  }), /*#__PURE__*/React.createElement("img", {
    alt: attachment.id,
    style: styles$6.image,
    src: attachment.file,
    className: "ce-photo-img",
    id: "image-" + attachment.id
  }));
};
var styles$6 = {
  container: {
    position: 'relative',
    width: 'calc(33% - 8px)',
    border: '1px solid white',
    display: 'inline-block',
    cursor: 'pointer'
  },
  image: {
    top: '0px',
    width: '100%',
    height: '100%',
    position: 'absolute',
    objectFit: 'cover'
  }
};

var PhotosSettings = function PhotosSettings(props) {
  var _useState = useState({
    collapsed: true,
    hovered: false
  }),
      state = _useState[0],
      setState = _useState[1];

  var chat = props.chat;

  function renderPhotos(attachments) {
    return attachments.map(function (attachment, index) {
      return /*#__PURE__*/React.createElement(Thumbnail, {
        key: "person_" + index,
        attachment: attachment
      });
    });
  }

  return /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px solid #f0f0f0'
    },
    className: "ce-photo-section"
  }, /*#__PURE__*/React.createElement("div", {
    onMouseEnter: function onMouseEnter() {
      return setState(_extends({}, state, {
        hovered: true
      }));
    },
    onMouseLeave: function onMouseLeave() {
      return setState(_extends({}, state, {
        hovered: false
      }));
    },
    onClick: function onClick() {
      return setState(_extends({}, state, {
        collapsed: !state.collapsed
      }));
    },
    style: state.hovered ? {
      backgroundColor: '#f0f0f0',
      cursor: 'pointer'
    } : {},
    className: "ce-section-title-container ce-photo-title-container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "ce-section-title ce-photo-title",
    style: {
      fontSize: '17px',
      padding: '12px',
      fontWeight: '600'
    }
  }, "Photos"), state.collapsed ? /*#__PURE__*/React.createElement(LeftOutlined, {
    style: styles$7.collapseIcon
  }) : /*#__PURE__*/React.createElement(DownOutlined, {
    style: styles$7.collapseIcon
  })), !state.collapsed && /*#__PURE__*/React.createElement("div", {
    className: "ce-photo-feed"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: '12px'
    }
  }), renderPhotos(chat.attachments)));
};
var styles$7 = {
  collapseIcon: {
    "float": 'right',
    position: 'relative',
    bottom: '30px',
    right: '12px'
  }
};

var OptionsSettings = function OptionsSettings(props) {
  var _useState = useState({
    collapsed: true,
    hovered: false
  }),
      state = _useState[0],
      setState = _useState[1];

  var chat = props.chat;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      borderTop: '1px solid #f0f0f0'
    }
  }, /*#__PURE__*/React.createElement("div", {
    id: "ce-options-drop-down",
    onMouseEnter: function onMouseEnter() {
      return setState(_extends({}, state, {
        hovered: true
      }));
    },
    onMouseLeave: function onMouseLeave() {
      return setState(_extends({}, state, {
        hovered: false
      }));
    },
    onClick: function onClick() {
      return setState(_extends({}, state, {
        collapsed: !state.collapsed
      }));
    },
    style: state.hovered ? {
      backgroundColor: '#f0f0f0',
      cursor: 'pointer'
    } : {}
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '17px',
      padding: '12px',
      fontWeight: '600'
    }
  }, "Options"), state.collapsed ? /*#__PURE__*/React.createElement(LeftOutlined, {
    style: styles$8.collapseIcon
  }) : /*#__PURE__*/React.createElement(DownOutlined, {
    style: styles$8.collapseIcon
  })), !state.collapsed && /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    style: {
      height: '12px'
    }
  }), /*#__PURE__*/React.createElement(Button$1, {
    value: "Delete",
    theme: "danger",
    icon: "delete",
    id: "ce-delete-chat-button",
    onClick: function onClick() {
      return deleteChat$1(props, chat.id, function (data) {});
    },
    style: {
      width: '100%',
      marginBottom: '12px'
    }
  })));
};
var styles$8 = {
  collapseIcon: {
    "float": 'right',
    position: 'relative',
    bottom: '30px',
    right: '12px'
  }
};

var NewMessageForm = function NewMessageForm(props) {
  var didMountRef = useRef(false);

  var _useState = useState({
    activeChat: null,
    value: ''
  }),
      state = _useState[0],
      setState = _useState[1];

  function _handleChange(event) {
    setState(_extends({}, state, {
      value: event.target.value
    }));
  }

  function handleSubmit(event) {
    event.preventDefault();
    editChat$1(props.conn, props.chat.id, {
      title: state.value
    }, function (data) {});
  }

  useEffect(function () {
    if (!didMountRef.current) {
      didMountRef.current = true;
    } else {
      if (state.activeChat !== props.chat.id) {
        setState(_extends({}, state, {
          value: props.chat.title,
          activeChat: props.chat.id
        }));
      }
    }
  });
  return /*#__PURE__*/React.createElement("form", {
    onSubmit: function onSubmit(e) {
      return handleSubmit(e);
    },
    className: "ce-chat-title-form"
  }, /*#__PURE__*/React.createElement(TextInput$1, {
    label: "Rename this Chat",
    value: state.value,
    "default": props.chat.title,
    handleChange: function handleChange(e) {
      return _handleChange(e);
    },
    style: {
      fontSize: '16px',
      fontWeight: '600',
      textAlign: 'center',
      border: '0px solid white',
      width: '100%'
    }
  }));
};

var ChatSettingsTop = function ChatSettingsTop(props) {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn;

  var chat = props.chat;
  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);
  var topPeople = chat.people.slice(0, 3);
  var otherPerson = getOtherPerson(chat.people);

  function renderOnePerson(people) {
    return /*#__PURE__*/React.createElement("div", {
      style: {
        width: '100%',
        paddingTop: '14px'
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        "float": 'left',
        position: 'relative',
        left: 'calc(50% - 22px)'
      }
    }, /*#__PURE__*/React.createElement(Avatar$1, {
      show_online: false,
      username: people[0].person.username,
      avatar: people[0].person.avatar
    })));
  }

  function renderTwoPeople(people) {
    return /*#__PURE__*/React.createElement("div", {
      style: {
        width: '100%',
        paddingTop: '14px'
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        "float": 'left',
        position: 'relative',
        left: 'calc(50% - 22px - 15px)'
      }
    }, /*#__PURE__*/React.createElement(Avatar$1, {
      show_online: false,
      username: people[0].person.username,
      avatar: people[0].person.avatar
    })), /*#__PURE__*/React.createElement("div", {
      style: {
        "float": 'left',
        position: 'relative',
        left: 'calc(50% - 44px - 22px + 15px)'
      }
    }, /*#__PURE__*/React.createElement(Avatar$1, {
      show_online: false,
      username: people[1].person.username,
      avatar: people[1].person.avatar
    })));
  }

  function renderThreePeople(people) {
    return /*#__PURE__*/React.createElement("div", {
      style: {
        width: '100%',
        paddingTop: '14px'
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        "float": 'left',
        position: 'relative',
        left: 'calc(50% - 22px - 24px)'
      }
    }, /*#__PURE__*/React.createElement(Avatar$1, {
      show_online: false,
      username: people[0].person.username,
      avatar: people[0].person.avatar
    })), /*#__PURE__*/React.createElement("div", {
      style: {
        "float": 'left',
        position: 'relative',
        left: 'calc(50% - 24px - 44px)'
      }
    }, /*#__PURE__*/React.createElement(Avatar$1, {
      show_online: false,
      username: people[1].person.username,
      avatar: people[1].person.avatar
    })), /*#__PURE__*/React.createElement("div", {
      style: {
        "float": 'left',
        position: 'relative',
        left: 'calc(50% - 22px - 44px - 44px + 24px)'
      }
    }, /*#__PURE__*/React.createElement(Avatar$1, {
      show_online: false,
      username: people[2].person.username,
      avatar: people[2].person.avatar
    })));
  }

  function getOtherPerson(people) {
    return people.find(function (person) {
      return person.person.username !== conn.userName;
    });
  }

  return /*#__PURE__*/React.createElement("div", {
    className: "ce-chat-settings-container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "ce-chat-avatars-row"
  }, topPeople.length === 1 && renderOnePerson(topPeople), chat.is_direct_chat && otherPerson && renderOnePerson([otherPerson]), !chat.is_direct_chat && otherPerson && topPeople.length === 2 && renderTwoPeople(topPeople), !chat.is_direct_chat && otherPerson && topPeople.length === 3 && renderThreePeople(topPeople)), chat.is_direct_chat && otherPerson ? /*#__PURE__*/React.createElement("div", {
    style: {
      paddingTop: '55px',
      paddingBottom: '7px',
      fontSize: '16px',
      fontWeight: '600',
      textAlign: 'center',
      border: '0px solid white',
      width: '100%'
    }
  }, otherPerson.person.username) : /*#__PURE__*/React.createElement(NewMessageForm, {
    chat: chat,
    conn: conn
  }));
};

var ChatSettings = function ChatSettings(props) {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      chats = _useContext.chats,
      activeChat = _useContext.activeChat;

  var chat = chats && chats[activeChat];
  if (props.renderChatSettings) return props.renderChatSettings(props);
  if (!chat) return /*#__PURE__*/React.createElement("div", {
    style: styles$9.filler
  });
  return /*#__PURE__*/React.createElement("div", {
    style: styles$9.settingsContainer,
    className: "ce-settings"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      width: '90%',
      paddingLeft: '5%'
    },
    className: "ce-settings-container"
  }, props.renderChatSettingsTop ? props.renderChatSettingsTop(conn, chat) : /*#__PURE__*/React.createElement(ChatSettingsTop, _extends({}, props, {
    chat: chat
  })), props.renderPeopleSettings ? props.renderPeopleSettings(conn, chat) : /*#__PURE__*/React.createElement(PeopleSettings, _extends({}, props, {
    chat: chat
  })), props.renderPhotosSettings ? props.renderPhotosSettings(chat) : /*#__PURE__*/React.createElement(PhotosSettings, _extends({}, props, {
    chat: chat
  })), props && chat && props.userName === chat.admin.username && /*#__PURE__*/React.createElement("div", null, props.renderOptionsSettings ? props.renderOptionsSettings(conn, chat) : /*#__PURE__*/React.createElement(OptionsSettings, _extends({}, props, {
    chat: chat
  })))));
};
var styles$9 = {
  settingsContainer: {
    height: '100%',
    overflow: 'scroll',
    overflowX: 'hidden',
    borderLeft: '1px solid #afafaf',
    backgroundColor: 'white',
    fontFamily: 'Avenir'
  },
  filler: {
    display: 'flex',
    width: '90%',
    paddingLeft: '5%',
    borderLeft: '1px solid #afafaf'
  }
};

var ChatSettingsDrawer = function ChatSettingsDrawer(props) {
  var _useState = useState(false),
      isOpen = _useState[0],
      setIsOpen = _useState[1];

  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(SettingOutlined, {
    onClick: function onClick() {
      return setIsOpen(true);
    },
    style: {
      color: 'rgb(24, 144, 255)',
      outline: 'none'
    }
  }), isOpen && /*#__PURE__*/React.createElement("div", {
    style: styles$a.drawerContainer
  }, /*#__PURE__*/React.createElement(CloseOutlined, {
    style: styles$a.closeIcon,
    onClick: function onClick() {
      return setIsOpen(false);
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: styles$a.titleContainer
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$a.titleText
  }, "Chat Settings")), /*#__PURE__*/React.createElement(ChatSettings, props)));
};
var styles$a = {
  drawerContainer: {
    position: 'fixed',
    zIndex: '1',
    top: '0px',
    left: '0px',
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
    textAlign: 'left'
  },
  closeIcon: {
    position: 'absolute',
    left: '28px',
    top: '32px'
  },
  titleContainer: {
    width: '100%',
    padding: '24px 0px',
    textAlign: 'center',
    color: 'rgb(24, 144, 255)'
  },
  titleText: {
    fontSize: '24px',
    fontWeight: '600'
  }
};

setConfiguration({
  maxScreenClass: 'xl',
  gutterWidth: 0
});

var ChatHeader = function ChatHeader() {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      chats = _useContext.chats,
      activeChat = _useContext.activeChat;

  if (!chats || !activeChat || !chats[activeChat]) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  if (!conn || conn === null) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  var chat = chats[activeChat];
  var otherPerson = chat.people.find(function (person) {
    return person.person.username !== conn.userName;
  });
  var title = chat.is_direct_chat && otherPerson ? otherPerson.person.username : chat.title;
  return /*#__PURE__*/React.createElement(Row, {
    className: "ce-chat-title",
    style: styles$b.titleSection
  }, /*#__PURE__*/React.createElement(Col, {
    xs: 2,
    sm: 0,
    style: _extends({}, styles$b.mobileOptiom, {
      left: '6px'
    }),
    className: "ce-chat-list-mobile-option"
  }, /*#__PURE__*/React.createElement(ChatListDrawer, null)), /*#__PURE__*/React.createElement(Col, {
    xs: 8,
    sm: 12,
    style: styles$b.titleContainer,
    className: "ce-chat-title-container"
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$b.titleText,
    className: "ce-chat-title-text",
    id: "ce-chat-feed-title-" + title
  }, title), /*#__PURE__*/React.createElement("div", {
    style: styles$b.subtitleText,
    className: "ce-chat-subtitle-text"
  }, chat.last_message.created && chat.last_message.created.length > 0 ? "Active " + timeSinceDate(chat.last_message.created) : 'Say hello!')), /*#__PURE__*/React.createElement(Col, {
    xs: 2,
    sm: 0,
    style: _extends({}, styles$b.mobileOptiom, {
      right: '6px'
    }),
    className: "ce-chat-settings-mobile-option"
  }, /*#__PURE__*/React.createElement(ChatSettingsDrawer, null)));
};
var styles$b = {
  titleSection: {
    position: 'absolute',
    top: '0px',
    width: '100%',
    zIndex: '1',
    backgroundColor: 'rgb(256, 256, 256, 0.92)',
    fontFamily: 'Avenir'
  },
  mobileOptiom: {
    width: '100%',
    top: '32px',
    textAlign: 'center',
    color: 'rgb(24, 144, 255)',
    overflow: 'hidden'
  },
  titleContainer: {
    width: '100%',
    padding: '18px 0px',
    textAlign: 'center',
    color: 'rgb(24, 144, 255)'
  },
  titleText: {
    fontSize: '24px',
    fontWeight: '600'
  },
  subtitleText: {
    fontSize: '12px'
  }
};

var RenderTrigger = function RenderTrigger(props) {
  var _useContext = useContext(ChatEngineContext);

  function useOnScreen(ref) {
    var _useState = useState(false),
        isIntersecting = _useState[0],
        setIntersecting = _useState[1];

    var observer = new IntersectionObserver(function (_ref) {
      var entry = _ref[0];
      setIntersecting(entry.isIntersecting);

      if (entry.isIntersecting) {
        props.onEnter && props.onEnter();
      } else {
        props.onLeave && props.onLeave();
      }
    });
    useEffect(function () {
      observer.observe(ref.current);
      return function () {
        observer.disconnect();
      };
    }, []);
    return isIntersecting;
  }

  var ref = useRef();
  var isVisible = useOnScreen(ref);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  });
};

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var suffix = ['st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st'];

var DatePartition = function DatePartition(props) {
  function getDate(date) {
    return date ? date.substr(0, 10) : null;
  }

  function formatDate(date_time) {
    if (!date_time) return '';
    var year = date_time.substr(0, 4);
    var month = months[parseInt(date_time.substr(5, 2)) - 1];
    var day = date_time.substr(8, 2);
    var dayDuffix = suffix[parseInt(date_time.substr(8, 2)) - 1];
    var time = date_time.substr(11, 5);
    var timeSuffix = '';

    if (parseInt(time.substr(0, 2)) >= 12) {
      if (parseInt(time.substr(0, 2)) > 12) {
        time = String(parseInt(time.substr(0, 2)) - 12) + ':' + time.substr(3, 2);
      }

      timeSuffix = 'PM';
    } else {
      timeSuffix = 'AM';
    }

    return time + timeSuffix + ', ' + month + ' ' + day + dayDuffix + ', ' + year;
  }

  var lastCreated = props.lastCreated,
      created = props.created;
  var lastDate = getDate(lastCreated);
  var thisDate = getDate(created);

  if (lastCreated && lastDate === thisDate) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  return /*#__PURE__*/React.createElement("div", {
    style: styles$c.dateText,
    className: "ce-message-date-text"
  }, formatDate(created));
};
var styles$c = {
  dateText: {
    width: '100%',
    textAlign: 'center',
    paddingTop: '4px',
    paddingBottom: '10px',
    fontSize: '15px',
    color: 'rgba(0, 0, 0, .40)'
  }
};

var _loadingContainer, _thumbnail;

var Thumbnail$1 = function Thumbnail(props) {
  var _useState = useState(false),
      hovered = _useState[0],
      setHovered = _useState[1];

  var attachment = props.attachment;

  var style = _extends({}, styles$d.thumbnail, {
    border: hovered ? '1px solid #1890ff' : '0px'
  });

  if (!attachment) {
    return /*#__PURE__*/React.createElement("div", {
      style: styles$d.loadingContainer
    }, /*#__PURE__*/React.createElement(LoadingOutlined, {
      style: {
        color: 'white',
        padding: '4px',
        fontSize: '28px'
      }
    }));
  }

  return /*#__PURE__*/React.createElement("img", {
    onClick: function onClick() {
      return window.open(attachment.file);
    },
    onMouseEnter: function onMouseEnter() {
      return setHovered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setHovered(false);
    },
    src: attachment.file,
    alt: 'thumb-nail',
    style: style
  });
};
var styles$d = {
  loadingContainer: (_loadingContainer = {
    width: '100%',
    cursor: 'pointer',
    textAlign: 'right',
    display: 'inline-block',
    objectFit: 'cover',
    borderRadius: '0.3em',
    marginRight: '2px',
    height: '30vw'
  }, _loadingContainer["width"] = '30vw', _loadingContainer.maxHeight = '200px', _loadingContainer.maxWidth = '200px', _loadingContainer.minHeight = '100px', _loadingContainer.minWidth = '100px', _loadingContainer.backgroundColor = '#d9d9d9', _loadingContainer),
  thumbnail: (_thumbnail = {
    width: '100%',
    cursor: 'pointer',
    textAlign: 'right',
    display: 'inline',
    objectFit: 'cover',
    borderRadius: '0.3em',
    paddingRight: '2px',
    height: '30vw'
  }, _thumbnail["width"] = '30vw', _thumbnail.maxHeight = '200px', _thumbnail.maxWidth = '200px', _thumbnail.minHeight = '100px', _thumbnail.minWidth = '100px', _thumbnail)
};

var colors = ['#D64045', '#5B3000', '#00CC99', '#467599', '#1D3354', '#8F250C', '#6153CC', '#961D4E', '#A29F15', '#0CAADC', '#FF5154', '#FA7921', '#688E26', '#550527', '#A10702', '#FF1053', '#6C6EA0', '#100B00'];

function stringToNumber(str) {
  var sum = 0;

  for (var i = 0; i < str.length; i++) {
    sum = sum + str.charCodeAt(i) * i - 97;
  }

  return sum;
}

function stringToColor(str) {
  if (!str) {
    return 'black';
  } else {
    return colors[stringToNumber(str) % colors.length];
  }
}

var Dot = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Dot, _Component);

  function Dot() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      avatar: ''
    };
    return _this;
  }

  var _proto = Dot.prototype;

  _proto.updateImg = function updateImg() {
    var avatar = this.props.avatar;
    avatar = avatar && avatar !== null ? avatar : '';

    if (avatar.split('?')[0] !== this.state.avatar.split('?')[0]) {
      this.setState({
        avatar: avatar
      });
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    this.updateImg();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.updateImg();
  };

  _proto.render = function render() {
    var username = this.props.username;
    var color = stringToColor(username);
    var customStyle = this.props.style ? this.props.style : {};
    return /*#__PURE__*/React.createElement("div", {
      className: "ce-avatar-dot",
      style: _extends({}, styles$e.dot, customStyle, {
        backgroundColor: this.state.avatar ? 'white' : color,
        backgroundImage: this.state.avatar && "url(" + this.state.avatar + ")",
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center',
        backgroundSize: '14px'
      })
    });
  };

  return Dot;
}(Component);
var styles$e = {
  dot: {
    width: '13px',
    height: '13px',
    borderRadius: '13px',
    textAlign: 'center'
  }
};

setConfiguration({
  maxScreenClass: 'xl'
});

var Message = function Message(props) {
  function renderReads() {
    var chat = props.chat,
        message = props.message;

    if (!chat) {
      return /*#__PURE__*/React.createElement("div", null);
    }

    return chat.people.map(function (chatPerson, index) {
      if (message.id === chatPerson.last_read) {
        return /*#__PURE__*/React.createElement(Dot, {
          key: "read_" + index,
          avatar: chatPerson.person.avatar,
          username: chatPerson.person.username,
          style: {
            "float": 'right',
            marginLeft: '4px'
          }
        });
      }

      return /*#__PURE__*/React.createElement("div", {
        key: "read_" + index
      });
    });
  }

  function renderAttachments() {
    var message = props.message;
    var attachments = message && message.attachments ? message.attachments : [];
    return attachments.map(function (attachment, index) {
      return /*#__PURE__*/React.createElement(Thumbnail$1, {
        attachment: attachment,
        key: "attachment_" + index
      });
    });
  }

  var lastMessage = props.lastMessage,
      message = props.message,
      nextMessage = props.nextMessage;

  if (!message) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  var attachments = message && message.attachments && message.attachments;
  var topRightRadius = !lastMessage || lastMessage.sender_username !== message.sender_username ? '1.3em' : '0.3em';
  var bottomRightRadius = !nextMessage || nextMessage.sender_username !== message.sender_username ? '1.3em' : '0.3em';
  var borderRadius = "1.3em " + topRightRadius + " " + bottomRightRadius + " 1.3em";
  var paddingBottom = !nextMessage || nextMessage.sender_username !== message.sender_username ? '12px' : '2px';
  return /*#__PURE__*/React.createElement("div", {
    className: "ce-message-row ce-my-message",
    style: {
      width: '100%',
      textAlign: 'right',
      paddingBottom: paddingBottom
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'auto'
    },
    className: "ce-my-message-attachments-container"
  }, renderAttachments()), /*#__PURE__*/React.createElement(Row, {
    style: {
      paddingRight: '2px'
    },
    className: "ce-message-bubble-row ce-my-message-bubble-row"
  }, /*#__PURE__*/React.createElement(Col, {
    xs: 1,
    sm: 2,
    md: 3
  }), /*#__PURE__*/React.createElement(Col, {
    xs: 11,
    sm: 10,
    md: 9
  }, !attachments || message.text && /*#__PURE__*/React.createElement("div", {
    className: "ce-message-bubble ce-my-message-bubble",
    style: _extends({}, styles$f.myMessage, {
      borderRadius: borderRadius
    })
  }, message.text)), /*#__PURE__*/React.createElement(Col, {
    xs: 1,
    sm: 2,
    md: 3
  }), /*#__PURE__*/React.createElement(Col, {
    xs: 12,
    className: "ce-reads-row ce-my-reads-row"
  }, renderReads())));
};
var styles$f = {
  myMessage: {
    color: 'white',
    cursor: 'pointer',
    "float": 'right',
    textAlign: 'left',
    padding: '12px',
    fontSize: '15px',
    whiteSpace: 'pre-line',
    backgroundColor: 'rgb(24, 144, 255)'
  }
};

setConfiguration({
  maxScreenClass: 'xl'
});

var TheirMessage = function TheirMessage(props) {
  function renderReads() {
    var chat = props.chat,
        message = props.message;

    if (!chat) {
      return /*#__PURE__*/React.createElement("div", null);
    }

    return chat.people.map(function (person, index) {
      if (message.id === person.last_read) {
        return /*#__PURE__*/React.createElement(Dot$1, {
          key: "read_" + index,
          avatar: person.person.avatar,
          username: person.person.username,
          style: {
            "float": 'left',
            marginLeft: '4px'
          }
        });
      }

      return /*#__PURE__*/React.createElement("div", {
        key: "read_" + index
      });
    });
  }

  function renderAttachments() {
    var message = props.message;
    var attachments = message && message.attachments ? props.message.attachments : [];
    return attachments.map(function (attachment, index) {
      return /*#__PURE__*/React.createElement(Thumbnail$1, {
        attachment: attachment,
        key: "attachment_" + index
      });
    });
  }

  var lastMessage = props.lastMessage,
      message = props.message,
      nextMessage = props.nextMessage;

  if (!message) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  var attachments = message && message.attachments && message.attachments;
  var topLeftRadius = !lastMessage || lastMessage.sender_username !== message.sender_username ? '1.3em' : '0.3em';
  var bottomLeftRadius = !nextMessage || nextMessage.sender_username !== message.sender_username ? '1.3em' : '0.3em';
  var borderRadius = topLeftRadius + " 1.3em 1.3em " + bottomLeftRadius;
  var paddingBottom = !nextMessage || nextMessage.sender_username !== message.sender_username ? '12px' : '2px';
  return /*#__PURE__*/React.createElement("div", {
    style: {
      width: '100%',
      paddingBottom: paddingBottom
    },
    className: "ce-message-row ce-their-message"
  }, (!lastMessage || lastMessage.sender_username !== message.sender_username) && /*#__PURE__*/React.createElement("div", {
    style: styles$g.nameText,
    className: "ce-their-message-sender"
  }, message.sender_username), /*#__PURE__*/React.createElement(Row, {
    style: {
      paddingLeft: '2px'
    },
    className: "ce-their-message-row"
  }, /*#__PURE__*/React.createElement(Col, {
    xs: 11,
    sm: 10,
    md: 9
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: '0px'
    },
    className: "ce-their-message-avatar"
  }, (!nextMessage || nextMessage.sender_username !== message.sender_username) && /*#__PURE__*/React.createElement(Avatar$1, {
    show_online: false,
    username: message.sender_username,
    avatar: message.sender && message.sender.avatar
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'auto',
      paddingLeft: '50px'
    },
    className: "ce-their-message-attachments-container"
  }, renderAttachments()), !attachments || message.text && /*#__PURE__*/React.createElement("div", {
    style: {
      paddingLeft: '48px'
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "ce-message-bubble ce-their-message-bubble",
    style: _extends({}, styles$g.theirMessage, {
      borderRadius: borderRadius
    })
  }, message.text))), /*#__PURE__*/React.createElement(Col, {
    xs: 9,
    style: {
      marginLeft: '48px'
    },
    className: "ce-reads-row ce-their-reads-row"
  }, renderReads())));
};
var styles$g = {
  theirMessage: {
    cusor: 'auto',
    color: 'black',
    "float": 'left',
    padding: '12px',
    fontSize: '15px',
    whiteSpace: 'pre-line',
    backgroundColor: '#f1f0f0'
  },
  nameText: {
    paddingLeft: '62px',
    paddingBottom: '2px',
    color: 'rgba(0, 0, 0, .40)',
    fontSize: '15px'
  }
};

setConfiguration({
  maxScreenClass: 'xl'
});

var SendingMessage = function SendingMessage(props) {

  function renderAttachments(attachments) {
    return attachments.map(function (a, index) {
      return /*#__PURE__*/React.createElement(Thumbnail$1, {
        key: "sending-file-" + index
      });
    });
  }

  var lastMessage = props.lastMessage,
      message = props.message,
      nextMessage = props.nextMessage;

  if (!message) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  var attachments = message && message.attachments ? message.attachments : [];
  var topRightRadius = !lastMessage || lastMessage.sender_username !== message.sender_username ? '1.3em' : '0.3em';
  var bottomRightRadius = !nextMessage || nextMessage.sender_username !== message.sender_username ? '1.3em' : '0.3em';
  var borderRadius = "1.3em " + topRightRadius + " " + bottomRightRadius + " 1.3em";
  var paddingBottom = !nextMessage || nextMessage.sender_username !== message.sender_username ? '12px' : '2px';
  return /*#__PURE__*/React.createElement("div", {
    className: "ce-message-row ce-my-message ce-my-message-sending",
    style: {
      width: '100%',
      textAlign: 'right',
      paddingBottom: paddingBottom
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'auto'
    },
    className: "ce-my-message-attachments-container"
  }, renderAttachments(attachments)), /*#__PURE__*/React.createElement(Row, {
    style: {
      paddingRight: '2px'
    },
    className: "ce-message-bubble-row ce-my-message-bubble-row ce-my-message-sending-row"
  }, /*#__PURE__*/React.createElement(Col, {
    xs: 1,
    sm: 2,
    md: 3
  }), /*#__PURE__*/React.createElement(Col, {
    xs: 11,
    sm: 10,
    md: 9
  }, message.text && /*#__PURE__*/React.createElement("div", {
    className: "ce-message-bubble ce-my-message-bubble",
    style: _extends({}, styles$h.myMessage, {
      borderRadius: borderRadius
    })
  }, message.text)), /*#__PURE__*/React.createElement(Col, {
    xs: 1,
    sm: 2,
    md: 3
  })));
};
var styles$h = {
  myMessage: {
    color: 'white',
    cursor: 'pointer',
    "float": 'right',
    textAlign: 'left',
    padding: '12px',
    fontSize: '15px',
    whiteSpace: 'pre-line',
    backgroundColor: '#40a9ff'
  }
};

var Message$1 = function Message$1(props) {
  var lastMessage = props.lastMessage,
      message = props.message,
      nextMessage = props.nextMessage,
      sending = props.sending,
      chat = props.chat;

  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn;

  if (!message || !chat) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  if (!conn || conn === null) {
    return /*#__PURE__*/React.createElement("div", null);
  }

  return /*#__PURE__*/React.createElement("div", {
    className: "ce-message-and-date"
  }, !sending && /*#__PURE__*/React.createElement(DatePartition, {
    lastCreated: lastMessage ? lastMessage.created : null,
    created: message.created
  }), sending ? /*#__PURE__*/React.createElement(SendingMessage, {
    chat: chat,
    conn: conn,
    lastMessage: lastMessage,
    message: message,
    nextMessage: nextMessage
  }) : /*#__PURE__*/React.createElement("div", null, message.sender_username === conn.userName || message.sender_username === conn.senderUsername ? /*#__PURE__*/React.createElement(Message, {
    chat: chat,
    conn: conn,
    lastMessage: lastMessage,
    message: message,
    nextMessage: nextMessage
  }) : /*#__PURE__*/React.createElement(TheirMessage, {
    chat: chat,
    conn: conn,
    lastMessage: lastMessage,
    message: message,
    nextMessage: nextMessage
  })));
};

var Messages = function Messages(props) {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      chats = _useContext.chats,
      messages = _useContext.messages,
      activeChat = _useContext.activeChat,
      setLoadMoreMessages = _useContext.setLoadMoreMessages,
      setIsBottomVisible = _useContext.setIsBottomVisible;

  var chat = chats && chats[activeChat];
  var keys = Object.keys(messages);
  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);
  return keys.map(function (key, index) {
    var message = messages[key];
    var lastMessageKey = index === 0 ? null : keys[index - 1];
    var nextMessageKey = index === keys.length - 1 ? null : keys[index + 1];

    if (props.renderMessageBubble) {
      return /*#__PURE__*/React.createElement("div", {
        key: "message_" + index
      }, props.renderMessageBubble(conn, chat, messages[lastMessageKey], message, messages[nextMessageKey]));
    }

    return /*#__PURE__*/React.createElement("div", {
      key: "message_" + index,
      id: "ce-message-" + message.id
    }, index === keys.length - 1 && /*#__PURE__*/React.createElement(RenderTrigger, {
      onEnter: function onEnter() {
        return setIsBottomVisible(true);
      },
      onLeave: function onLeave() {
        return setIsBottomVisible(false);
      }
    }), /*#__PURE__*/React.createElement(Message$1, {
      chat: chat,
      message: message,
      lastMessage: messages[lastMessageKey],
      nextMessage: messages[nextMessageKey]
    }), index === 0 && /*#__PURE__*/React.createElement(RenderTrigger, {
      onEnter: function onEnter() {
        return setLoadMoreMessages(true);
      }
    }));
  });
};

var SendingMessages = function SendingMessages(props) {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      chats = _useContext.chats,
      activeChat = _useContext.activeChat,
      sendingMessages = _useContext.sendingMessages;

  var keys = Object.keys(sendingMessages);
  var chat = chats && chats[activeChat];
  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);
  return keys.map(function (key, index) {
    var message = sendingMessages[key];
    var lastMessageKey = index === 0 ? null : keys[index - 1];
    var nextMessageKey = index === keys.length - 1 ? null : keys[index + 1];

    if (message && message.chat === activeChat) {
      return /*#__PURE__*/React.createElement(Message$1, {
        sending: true,
        key: "sending-msg-" + index,
        chat: chat,
        message: message,
        lastMessage: sendingMessages[lastMessageKey],
        nextMessage: sendingMessages[nextMessageKey]
      });
    }
  });
};

var Typers = function Typers(props) {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      activeChat = _useContext.activeChat,
      typingCounter = _useContext.typingCounter;

  var typers = typingCounter && typingCounter[activeChat] ? typingCounter[activeChat] : [];
  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);

  if (props.renderIsTyping) {
    return props.renderIsTyping(typers);
  }

  return /*#__PURE__*/React.createElement("div", null, Object.keys(typers).map(function (username, index) {
    if (conn.userName !== username && props.currentTime < typers[username] + 2000) {
      return /*#__PURE__*/React.createElement("div", {
        key: "typer_" + index,
        style: {
          color: stringToColor(username),
          padding: '2px',
          paddingLeft: '12px'
        }
      }, username + " is typing...");
    } else {
      return /*#__PURE__*/React.createElement("div", {
        key: "typer_" + index
      });
    }
  }));
};

var Thumbnail$2 = function Thumbnail(props) {
  var _useState = useState(false),
      hovered = _useState[0],
      setHovered = _useState[1];

  var _useState2 = useState(''),
      blob = _useState2[0],
      setBlob = _useState2[1];

  useEffect(function () {
    setBlob(URL.createObjectURL(props.file));
  }, [props.file]);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: '12px 6px',
      display: 'inline-block',
      position: "relative"
    },
    onMouseEnter: function onMouseEnter() {
      return setHovered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setHovered(false);
    }
  }, /*#__PURE__*/React.createElement("img", {
    style: styles$i.imageSquare,
    alt: props.file ? props.file.name : '',
    src: blob
  }), hovered && /*#__PURE__*/React.createElement(CloseCircleTwoTone, {
    style: styles$i.closeIcon,
    onClick: function onClick() {
      return props.onRemove && props.onRemove();
    }
  }));
};
var styles$i = {
  imageSquare: {
    height: '108px',
    width: '108px',
    border: '1px solid #afafaf',
    borderRadius: '8px',
    objectFit: 'cover',
    display: 'inline'
  },
  closeIcon: {
    position: 'absolute',
    bottom: 'calc(100% - 32px)',
    left: '96px',
    width: '0px',
    cursor: 'pointer'
  }
};

var FileRow = function FileRow(props) {
  function renderFiles() {
    return props.files.map(function (file, index) {
      return /*#__PURE__*/React.createElement(Thumbnail$2, {
        file: file,
        key: "thumb_" + index,
        onRemove: function onRemove() {
          return props.onRemove && props.onRemove(index);
        }
      });
    });
  }

  return /*#__PURE__*/React.createElement("div", {
    style: {
      width: 'calc(100% - 24px)',
      paddingLeft: '12px'
    }
  }, renderFiles());
};

var ImagesInput = function ImagesInput(props) {
  var _useState = useState({
    hovered: false
  }),
      state = _useState[0],
      setState = _useState[1];

  function onSelect(event) {
    var files = Array.from(event.target.files);
    props.onSelectFiles && props.onSelectFiles(files);
  }

  return /*#__PURE__*/React.createElement("form", {
    className: "uploader",
    encType: "multipart/form-data",
    style: {
      height: '0px'
    }
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "files",
    id: "upload-document-button"
  }, /*#__PURE__*/React.createElement(PaperClipOutlined, {
    onMouseEnter: function onMouseEnter() {
      return setState(_extends({}, state, {
        hovered: true
      }));
    },
    onMouseLeave: function onMouseLeave() {
      return setState(_extends({}, state, {
        hovered: false
      }));
    },
    style: _extends({}, {
      cursor: 'pointer',
      position: 'absolute',
      bottom: '20px',
      right: '63px',
      fontSize: '18px'
    }, {
      color: state.hovered ? '#69c0ff' : '#1890ff'
    })
  })), /*#__PURE__*/React.createElement("input", {
    multiple: true,
    id: "files",
    accept: "image/x-png,image/gif,image/jpeg",
    style: {
      visibility: "hidden"
    },
    type: "file",
    onChange: function onChange(e) {
      return onSelect(e);
    },
    onClick: function onClick(e) {
      return e.target.value = null;
    }
  }));
};

var MessageInput = /*#__PURE__*/function (_Component) {
  _inheritsLoose(MessageInput, _Component);

  function MessageInput() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      focused: false,
      value: null,
      height: 0
    };
    return _this;
  }

  var _proto = MessageInput.prototype;

  _proto.resize = function resize() {
    var textarea = document.getElementById("msg-textarea");
    textarea.style.height = "";
    textarea.style.height = Math.min(textarea.scrollHeight, 150) + "px";
    this.setState({
      height: Math.min(textarea.scrollHeight, 150)
    });
  };

  _proto.componentDidMount = function componentDidMount() {
    this.resize();
  };

  _proto.handleChange = function handleChange(e) {
    this.resize();
    this.props.handleChange && this.props.handleChange(e);
  };

  _proto.onKeyDown = function onKeyDown(e) {
    if (e.key === 'Enter') {
      e.preventDefault();

      if (this.props.value.length > 0) {
        this.props.onSubmit && this.props.onSubmit(e);
      }
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var style = _extends({}, styles$j.input, {
      overflowY: this.state.height === 150 ? 'scroll' : 'hidden'
    });

    return /*#__PURE__*/React.createElement("textarea", {
      id: "msg-textarea",
      className: "ce-input ce-textarea-input",
      rows: "1",
      style: style,
      value: this.props.value,
      placeholder: this.props.label,
      onBlur: function onBlur() {
        return _this2.setState({
          focused: false
        });
      },
      onFocus: function onFocus() {
        return _this2.setState({
          focused: true
        });
      },
      type: this.props.type ? this.props.type : "text",
      onChange: function onChange(e) {
        return _this2.handleChange(e);
      },
      onKeyDown: function onKeyDown(e) {
        return _this2.onKeyDown(e);
      }
    });
  };

  return MessageInput;
}(Component);
var styles$j = {
  input: {
    border: '1px solid white',
    width: 'calc(100% - 64px - 24px - 44px)',
    outline: 'none',
    fontSize: '15px',
    fontFamily: 'Avenir',
    paddingLeft: '12px',
    paddingRight: '12px',
    position: 'relative',
    left: '12px',
    resize: 'none',
    overflowX: 'hidden'
  }
};

var _this$2 = undefined;

var NewMessageForm$1 = function NewMessageForm() {
  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      activeChat = _useContext.activeChat,
      sendingMessages = _useContext.sendingMessages,
      setSendingMessages = _useContext.setSendingMessages;

  var _useState = useState({
    trigger: 0,
    mod: 3,
    value: '',
    attachments: []
  }),
      state = _useState[0],
      setState = _useState[1];

  if (!conn || conn === null) return /*#__PURE__*/React.createElement("div", null);

  function _onRemove(index) {
    var attachments = state.attachments;
    attachments.splice(index, 1);
    setState(_extends({}, state, {
      attachments: attachments
    }));
  }

  function handleChange(event) {
    setState(_extends({}, state, {
      value: event.target.value,
      trigger: (state.trigger + 1) % state.mod
    }));

    if (state.trigger === 1) {
      isTyping$1(conn, activeChat);
    }
  }

  function handleSubmit(event) {
    event.preventDefault();
    var attachments = state.attachments;
    var text = state.value.trim();
    var custom_json = {
      sender_id: Date.now().toString()
    };
    var sender_username = conn.userName ? conn.userName : conn.senderUsername;
    var data = {
      text: text,
      attachments: attachments,
      custom_json: custom_json,
      sender_username: sender_username,
      chat: activeChat
    };

    if (text.length > 0 || attachments.length > 0) {
      sendMessage$1(conn, activeChat, data, function (data) {});
    }

    setState(_extends({}, state, {
      value: '',
      attachments: []
    }));
    var textarea = document.getElementById("msg-textarea");
    textarea.style.height = "24px";

    var newSendingMessages = _extends({}, sendingMessages);

    newSendingMessages[data.custom_json.sender_id] = data;
    setSendingMessages(newSendingMessages);
  }

  return /*#__PURE__*/React.createElement("div", {
    id: "msg-form-container",
    style: styles$k.NewMessageFormContainer,
    className: "ce-message-form-container"
  }, /*#__PURE__*/React.createElement(FileRow, {
    files: state.attachments,
    onRemove: function onRemove(i) {
      return _onRemove(i);
    }
  }), /*#__PURE__*/React.createElement(ImagesInput, {
    onSelectFiles: function onSelectFiles(attachments) {
      return setState(_extends({}, state, {
        attachments: attachments
      }));
    }
  }), /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit.bind(_this$2),
    className: "ce-message-form"
  }, /*#__PURE__*/React.createElement("div", {
    style: styles$k.inputContainer,
    className: "ce-message-input-form"
  }, /*#__PURE__*/React.createElement(MessageInput, {
    value: state.value,
    label: "Send a message...",
    handleChange: handleChange.bind(_this$2),
    onSubmit: handleSubmit.bind(_this$2)
  }), /*#__PURE__*/React.createElement(Button$1, {
    icon: "send",
    type: "submit",
    id: "ce-send-message-button",
    style: {
      position: 'absolute',
      bottom: '10px',
      right: '6px'
    }
  }))));
};
var styles$k = {
  NewMessageFormContainer: {
    position: 'absolute',
    bottom: '0px',
    width: '100%',
    backgroundColor: 'white'
  },
  inputContainer: {
    minHeight: '36px',
    paddingTop: '10px',
    paddingBottom: '6px'
  }
};

var initial = 45;
var count$1 = initial;
var interval$1 = 33;

var ChatFeed = function ChatFeed(props) {
  var didMountRef = useRef(false);

  var _useState = useState(0),
      duration = _useState[0],
      setDuration = _useState[1];

  var _useState2 = useState(null),
      currentChat = _useState2[0],
      setCurrentChat = _useState2[1];

  var _useState3 = useState(Date.now()),
      currentTime = _useState3[0],
      setCurrentTime = _useState3[1];

  var _useContext = useContext(ChatEngineContext),
      conn = _useContext.conn,
      chats = _useContext.chats,
      setChats = _useContext.setChats,
      sendingMessages = _useContext.sendingMessages,
      messages = _useContext.messages,
      setMessages = _useContext.setMessages,
      activeChat = _useContext.activeChat,
      setActiveChat = _useContext.setActiveChat,
      loadMoreMessages = _useContext.loadMoreMessages,
      setLoadMoreMessages = _useContext.setLoadMoreMessages,
      isBottomVisible = _useContext.isBottomVisible;

  function onReadMessage(chat) {
    if (chats) {
      var newChats = _extends({}, chats);

      newChats[chat.id] = chat;
      setChats(newChats);
    }
  }

  function onGetMessages(chatId, messages, scrollDownTo) {
    setMessages(_$1.mapKeys(messages, 'id'));

    if (messages.length > 0) {
      var message = messages[messages.length - 1];

      if (props.userName && props.userName !== message.sender_username) {
        readMessage(conn, chatId, message.id, function (chat) {
          return onReadMessage(chat);
        });
      }
    }

    if (scrollDownTo) {
      animateScroll.scrollToBottom({
        duration: 0,
        containerId: scrollDownTo
      });
    }

    props.onGetMessages && props.onGetMessages(chatId, messages);
  }

  function loadMessages(loadMoreMessages) {
    if (loadMoreMessages) {
      count$1 = count$1 + interval$1;
      setLoadMoreMessages(false);
      getLatestMessages(conn, activeChat, count$1, function (chatId, messages) {
        return onGetMessages(chatId, messages, false);
      });
    } else if (conn && !props.activeChat && activeChat !== null && activeChat !== currentChat) {
      count$1 = initial;
      setCurrentChat(activeChat);
      getLatestMessages(conn, activeChat, count$1, function (chatId, messages) {
        return onGetMessages(chatId, messages, "ce-feed-container");
      });
    } else if (conn && props.activeChat && props.activeChat !== currentChat) {
      count$1 = initial;
      setActiveChat(props.activeChat);
      setCurrentChat(props.activeChat);
      getLatestMessages(conn, props.activeChat, count$1, function (chatId, messages) {
        return onGetMessages(chatId, messages, "ce-feed-container");
      });
    }
  }

  useEffect(function () {
    loadMessages(false);
  }, [conn, activeChat, currentChat]);
  useEffect(function () {
    loadMessages(loadMoreMessages);
  }, [loadMoreMessages]);
  useEffect(function () {
    if (!didMountRef.current) {
      didMountRef.current = true;
      setTimeout(function () {
        setDuration(100);
      }, 3000);
      setInterval(function () {
        setCurrentTime(Date.now());
      }, 1000);
    } else {
      if (isBottomVisible && !_$1.isEmpty(messages)) {
        animateScroll.scrollToBottom({
          duration: duration,
          containerId: "ce-feed-container"
        });
      }
    }
  }, [sendingMessages, messages, isBottomVisible]);
  var chat = chats && chats[currentChat];

  if (props.renderChatFeed) {
    return props.renderChatFeed(props);
  } else if (conn === undefined) {
    return /*#__PURE__*/React.createElement(AuthFail, null);
  } else if (conn && chats !== null && _$1.isEmpty(chats)) {
    return /*#__PURE__*/React.createElement(Welcome, null);
  }

  return /*#__PURE__*/React.createElement("div", {
    className: "ce-chat-feed",
    style: {
      height: '100%',
      maxHeight: '100vh',
      backgroundColor: '#f0f0f0'
    }
  }, props.renderChatHeader ? props.renderChatHeader(chat) : /*#__PURE__*/React.createElement(ChatHeader, null), /*#__PURE__*/React.createElement("div", {
    id: "ce-feed-container",
    style: styles$l.feedContainer,
    className: "ce-chat-feed-container"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: '88px'
    },
    className: "ce-feed-container-top"
  }), /*#__PURE__*/React.createElement(Messages, props), /*#__PURE__*/React.createElement(SendingMessages, props), /*#__PURE__*/React.createElement(Typers, {
    currentTime: currentTime
  }), /*#__PURE__*/React.createElement(ConnectionBar, null), /*#__PURE__*/React.createElement("div", {
    style: {
      height: '54px'
    },
    className: "ce-feed-container-bottom"
  })), props.renderNewMessageForm ? props.renderNewMessageForm(props, currentChat) : /*#__PURE__*/React.createElement(NewMessageForm$1, null));
};
var styles$l = {
  feedContainer: {
    width: '100%',
    height: '100%',
    maxHeight: '100vh',
    overflowX: 'hidden',
    overflowY: 'scroll',
    backgroundColor: 'white',
    fontFamily: 'Avenir'
  }
};

setConfiguration({
  maxScreenClass: 'xl',
  gutterWidth: 0
});

var ChatEngine = function ChatEngine(props) {
  var context = useContext(ChatEngineContext);
  var height = props.height;

  var propsAndContext = _extends({}, props, context);

  return /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: 'left',
      backgroundColor: 'white'
    }
  }, /*#__PURE__*/React.createElement(Socket, props), /*#__PURE__*/React.createElement(Row, null, /*#__PURE__*/React.createElement(Col, {
    xs: 0,
    sm: 3,
    style: {
      height: height ? height : ''
    }
  }, /*#__PURE__*/React.createElement(ChatList, propsAndContext)), /*#__PURE__*/React.createElement(Col, {
    xs: 12,
    sm: 6,
    style: {
      height: height ? height : ''
    }
  }, /*#__PURE__*/React.createElement(ChatFeed, propsAndContext)), /*#__PURE__*/React.createElement(Col, {
    xs: 0,
    sm: 3,
    style: {
      height: height ? height : ''
    }
  }, /*#__PURE__*/React.createElement(ChatSettings, propsAndContext))));
};

var ChatEngineApp = function ChatEngineApp(props) {
  if (useContext(ChatEngineContext)) {
    return /*#__PURE__*/React.createElement(ChatEngine, props);
  } else {
    return /*#__PURE__*/React.createElement(ChatEngineWrapper, null, /*#__PURE__*/React.createElement(ChatEngine, props));
  }
};

var _this$3 = undefined;

var ChatSocket = function ChatSocket(props) {
  var _useState = useState(Date.now() + 10000),
      reconnect = _useState[0];

  var _useContext = useContext(ChatEngineContext),
      setConnecting = _useContext.setConnecting,
      conn = _useContext.conn,
      setConn = _useContext.setConn,
      setCreds = _useContext.setCreds,
      chats = _useContext.chats,
      setChats = _useContext.setChats,
      messages = _useContext.messages,
      setMessages = _useContext.setMessages,
      sendingMessages = _useContext.sendingMessages,
      setSendingMessages = _useContext.setSendingMessages,
      activeChat = _useContext.activeChat,
      setActiveChat = _useContext.setActiveChat,
      typingCounter = _useContext.typingCounter,
      setTypingCounter = _useContext.setTypingCounter;

  function onEditChat(chat) {
    if (chats) {
      var newChats = _extends({}, chats);

      newChats[chat.id] = chat;
      setChats(newChats);
    }

    props.onEditChat && props.onEditChat(chat);
  }

  function onGetChat(chat) {
    if (activeChat === null) {
      setActiveChat(chat.id);
    }

    setChats(_.mapKeys([chat], 'id'));
  }

  function onConnect(conn) {
    setConn(conn);
    setCreds(conn);
    setConnecting(false);
    getChat$1(conn, props.chatID, function (chat) {
      return onGetChat(chat);
    });

    if (Date.now() > reconnect) {
      getLatestMessages$1(conn, props.chatID, 45, function (id, list) {
        setMessages(_extends({}, messages, _.mapKeys(list, 'id')));
      });
    }

    props.onConnect && props.onConnect(conn);
  }

  function handleEvent(event) {
    var eventJSON = JSON.parse(event);

    if (eventJSON.action === 'login_error') {
      console.log("Your chat auth credentials were not correct: \n\n                Project ID: " + props.projectID + " \n\n                Chat ID: " + props.chatID + " \n\n                Access Key: " + props.chatAccessKey + "\n\n                Double check these credentials to make sure they're correct.\n\n                If all three are correct, try resetting the username and secret in the Online Dashboard or Private API.");
      setConn(undefined);
      setCreds(undefined);
      props.onFailAuth && props.onFailAuth(conn);
    } else if (eventJSON.action === 'edit_chat') {
      onEditChat(eventJSON.data);
    } else if (eventJSON.action === 'delete_chat') {
      var chat = eventJSON.data;

      if (chats) {
        chats[chat.id] = undefined;
        setChats(chats);
      }

      props.onDeleteChat && props.onDeleteChat(chat);
    } else if (eventJSON.action === 'add_person') {
      onEditChat(eventJSON.data);
      props.onAddPerson && props.onAddPerson(eventJSON.data);
    } else if (eventJSON.action === 'remove_person') {
      onEditChat(eventJSON.data);
      props.onRemovePerson && props.onRemovePerson(eventJSON.data);
    } else if (eventJSON.action === 'new_message') {
      var _eventJSON$data = eventJSON.data,
          id = _eventJSON$data.id,
          message = _eventJSON$data.message;

      if (typeof message.custom_json === "string" && message.custom_json.indexOf('sender_id') !== -1) {
        sendingMessages[JSON.parse(message.custom_json).sender_id] = undefined;
        setSendingMessages(sendingMessages);
      }

      if (id === activeChat) {
        var newMessages = _extends({}, messages);

        newMessages[message.id] = message;
        setMessages(newMessages);
      }

      props.onNewMessage && props.onNewMessage(id, message);
    } else if (eventJSON.action === 'edit_message') {
      var _eventJSON$data2 = eventJSON.data,
          _id = _eventJSON$data2.id,
          _message = _eventJSON$data2.message;

      if (_id === activeChat) {
        messages[_message.id] = _message;
        setMessages(messages);
      }

      props.onEditMessage && props.onEditMessage(_id, _message);
    } else if (eventJSON.action === 'delete_message') {
      var _eventJSON$data3 = eventJSON.data,
          _id2 = _eventJSON$data3.id,
          _message2 = _eventJSON$data3.message;

      if (_id2 === activeChat) {
        messages[_message2.id] = undefined;
        setMessages(messages);
      }

      props.onDeleteMessage && props.onDeleteMessage(_id2, _message2);
    } else if (eventJSON.action === 'is_typing') {
      var _extends2, _extends3;

      var _eventJSON$data4 = eventJSON.data,
          _id3 = _eventJSON$data4.id,
          person = _eventJSON$data4.person;

      var newTypingCounter = _extends({}, typingCounter);

      newTypingCounter = _extends({}, newTypingCounter, (_extends3 = {}, _extends3[_id3] = _extends({}, newTypingCounter[_id3], (_extends2 = {}, _extends2[person] = Date.now(), _extends2)), _extends3));
      setTypingCounter(newTypingCounter);
      props.onTyping && props.onTyping(_id3, person);
    }
  }

  function onClose() {
    setConnecting(true);
  }

  var development = props.development,
      publicKey = props.publicKey,
      projectID = props.projectID,
      chatID = props.chatID,
      chatAccessKey = props.chatAccessKey;
  var wsStart = development ? 'ws://' : 'wss://';
  var rootHost = development ? '127.0.0.1:8000' : 'api.chatengine.io';
  var project = publicKey ? publicKey : projectID;
  return /*#__PURE__*/React.createElement(WebSocket, {
    url: "" + wsStart + rootHost + "/chat/?projectID=" + project + "&chatID=" + chatID + "&accessKey=" + chatAccessKey,
    onOpen: function onOpen() {
      return onConnect(props);
    },
    onClose: onClose.bind(_this$3),
    onMessage: handleEvent.bind(_this$3),
    reconnectIntervalInMilliSeconds: 3000
  });
};

var Avatar = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Avatar, _Component);

  function Avatar() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      avatar: ''
    };
    return _this;
  }

  var _proto = Avatar.prototype;

  _proto.updateImg = function updateImg() {
    var avatar = this.props.avatar;
    avatar = avatar && avatar !== null ? avatar : '';

    if (avatar.split('?')[0] !== this.state.avatar.split('?')[0]) {
      this.setState({
        avatar: avatar
      });
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    this.updateImg();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.updateImg();
  };

  _proto.render = function render() {
    var _this$props = this.props,
        username = _this$props.username,
        is_online = _this$props.is_online;
    var customStyle = this.props.style ? this.props.style : {};
    var text = username ? username.substring(0, 2).toUpperCase() : '';
    var color = stringToColor(username);
    return /*#__PURE__*/React.createElement("div", {
      style: {
        width: '48px',
        height: '48px'
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        height: '0px'
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: "ce-avatar",
      style: _extends({}, styles$m.avatar, customStyle, {
        backgroundColor: this.state.avatar ? 'white' : color,
        backgroundImage: this.state.avatar && "url(" + this.state.avatar + ")",
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center',
        backgroundSize: '48px'
      })
    }, /*#__PURE__*/React.createElement("div", {
      className: "ce-avatar-text",
      style: styles$m.avatarText
    }, !this.state.avatar && text))), this.props.show_online !== false && /*#__PURE__*/React.createElement("div", {
      className: "ce-avatar-status",
      style: _extends({}, styles$m.status, {
        backgroundColor: is_online ? '#52c41a' : '#f5222d'
      })
    }));
  };

  return Avatar;
}(Component);
var styles$m = {
  avatar: {
    width: '44px',
    height: '44px',
    borderRadius: '22px',
    color: 'white',
    textAlign: 'center'
  },
  avatarText: {
    color: 'white',
    paddingTop: '12px',
    fontSize: '15px',
    fontWeight: '600'
  },
  status: {
    width: '8px',
    height: '8px',
    borderRadius: '100%',
    border: '2px solid white'
  }
};

var _dangerButton;

var Button = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Button, _Component);

  function Button() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      hovered: false
    };
    return _this;
  }

  var _proto = Button.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        value = _this$props.value,
        icon = _this$props.icon,
        theme = _this$props.theme,
        style = _this$props.style;
    var customStyle = style ? style : {};
    var hoverStyle = this.state.hovered ? styles$n.hoverButton : {};
    var themeStyle = theme === 'danger' ? styles$n.dangerButton : styles$n.button;
    return /*#__PURE__*/React.createElement("button", {
      id: this.props.id,
      type: this.props.type,
      onClick: function onClick() {
        return _this2.props.onClick && _this2.props.onClick();
      },
      onMouseEnter: function onMouseEnter() {
        return _this2.setState({
          hovered: true
        });
      },
      onMouseLeave: function onMouseLeave() {
        return _this2.setState({
          hovered: false
        });
      },
      style: _extends({}, themeStyle, customStyle, hoverStyle),
      className: "ce-primary-button " + (theme === 'danger' ? 'ce-danger-button' : '')
    }, icon === 'plus' && /*#__PURE__*/React.createElement(PlusOutlined, null), icon === 'send' && /*#__PURE__*/React.createElement(ArrowUpOutlined, null), icon === 'delete' && /*#__PURE__*/React.createElement(DeleteOutlined, null), icon === 'user-add' && /*#__PURE__*/React.createElement(UserAddOutlined, null), value && icon ? " " + value : value);
  };

  return Button;
}(Component);
var styles$n = {
  button: {
    color: 'white',
    border: 'none',
    outline: 'none',
    height: '36px',
    fontSize: '15px',
    cursor: 'pointer',
    padding: '8px 16px',
    borderRadius: '33px',
    backgroundColor: '#1890ff'
  },
  dangerButton: (_dangerButton = {
    color: 'red',
    border: 'none',
    outline: 'none',
    height: '36px',
    fontSize: '15px',
    cursor: 'pointer',
    padding: '8px 16px',
    borderRadius: '33px',
    backgroundColor: 'white'
  }, _dangerButton["border"] = '1px solid red', _dangerButton),
  hoverButton: {
    opacity: '0.66'
  }
};

var TextInput = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TextInput, _Component);

  function TextInput() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      focused: false,
      value: null
    };
    return _this;
  }

  var _proto = TextInput.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var value = this.props["default"];

    if (value) {
      var event = {
        target: {
          value: value
        }
      };
      this.props.handleChange(event);
      this.setState({
        value: value
      });
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var customStyle = this.props.style ? this.props.style : {};
    var defaultStyle = this.state.focused ? styles$o.focusInput : styles$o.input;
    return (
      /*#__PURE__*/
      React.createElement("input", {
        id: this.props.id,
        autoFocus: this.props.autoFocus,
        className: "ce-input ce-text-input",
        value: this.props.value,
        placeholder: this.props.label,
        style: _extends({}, defaultStyle, customStyle),
        onBlur: function onBlur() {
          _this2.setState({
            focused: false
          });

          _this2.props.onBlur && _this2.props.onBlur();
        },
        onFocus: function onFocus() {
          _this2.setState({
            focused: true
          });

          _this2.props.onFocus && _this2.props.onFocus();
        },
        type: this.props.type ? this.props.type : "text",
        onChange: function onChange(e) {
          return _this2.props.handleChange && _this2.props.handleChange(e);
        }
      })
    );
  };

  return TextInput;
}(Component);
var styles$o = {
  input: {
    height: '36px',
    fontSize: '15px',
    fontFamily: 'Avenir',
    outline: 'none',
    borderRadius: '24px',
    border: '1px solid #d9d9d9',
    padding: '0px 12px',
    boxSizing: 'border-box'
  },
  focusInput: {
    height: '36px',
    fontSize: '15px',
    fontFamily: 'Avenir',
    outline: 'none',
    borderRadius: '24px',
    border: '1px solid #1890ff',
    padding: '0px 12px',
    boxSizing: 'border-box'
  }
};

var AutoComplete = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AutoComplete, _Component);

  function AutoComplete() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      focused: false,
      showAll: false
    };
    return _this;
  }

  var _proto = AutoComplete.prototype;

  _proto.onFocus = function onFocus() {
    this.onChange('', true);
    this.setState({
      focused: true
    });
    this.props.onFocus && this.props.onFocus();
  };

  _proto.onBlur = function onBlur() {
    this.setState({
      focused: false
    });
    this.props.onBlur && this.props.onBlur();
  };

  _proto.onChange = function onChange(value, showAll) {
    this.setState({
      showAll: showAll
    });
    this.props.handleChange && this.props.handleChange(value);
  };

  _proto.getNames = function getNames() {
    var _this2 = this;

    var count = 0;
    var max = this.props.max ? this.props.max : 3;
    var results = [];
    this.props.options.map(function (option) {
      if (JSON.stringify(option).toLowerCase().indexOf(_this2.props.value.toLowerCase()) !== -1 && count < max) {
        count = count + 1;
        results.push(option);
      }
    });
    return results;
  };

  _proto.renderOptions = function renderOptions() {
    var _this3 = this;

    if (!this.props.value && !this.state.showAll) {
      return /*#__PURE__*/React.createElement("div", null);
    }

    var results = this.getNames();
    return results.map(function (option, index) {
      return /*#__PURE__*/React.createElement("div", {
        key: "option_" + index,
        className: "ce-autocomplete-option"
      }, _this3.props.renderOption && _this3.props.renderOption(option), index === results.length - 1 && /*#__PURE__*/React.createElement("div", {
        style: styles$p.close,
        className: "ce-autocomplete-close",
        onClick: function onClick() {
          return _this3.onChange('', false);
        }
      }, /*#__PURE__*/React.createElement(CloseOutlined, null)));
    });
  };

  _proto.render = function render() {
    var _this4 = this;

    var options = this.props.options;
    var customStyle = this.props.style ? this.props.style : {};

    var defaultStyle = _extends({}, styles$p.input, {
      border: this.state.focused ? '1px solid #1890ff' : '1px solid #d9d9d9'
    });

    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("input", {
      id: "ce-add-username-input",
      className: "ce-input ce-autocomplete-input",
      value: this.props.value,
      placeholder: this.props.label,
      style: _extends({}, defaultStyle, customStyle),
      type: this.props.type ? this.props.type : "text",
      onBlur: function onBlur() {
        return _this4.onBlur();
      },
      onFocus: function onFocus() {
        return _this4.onFocus();
      },
      onChange: function onChange(e) {
        return _this4.onChange(e.target.value, true);
      }
    }), options && options.length > 0 && this.state.showAll && /*#__PURE__*/React.createElement("div", {
      className: "ce-autocomplete-options",
      style: {
        borderRadius: '19px',
        border: '1px solid #afafaf',
        overflow: 'hidden'
      }
    }, this.props.options && this.renderOptions()));
  };

  return AutoComplete;
}(Component);
var styles$p = {
  input: {
    height: '36px',
    fontSize: '15px',
    outline: 'none',
    borderRadius: '24px',
    padding: '0px 12px',
    boxSizing: 'border-box',
    fontFamily: 'Avenir'
  },
  close: {
    cursor: 'pointer',
    textAlign: 'center',
    padding: '8px 12px',
    fontSize: '15px',
    borderRadius: '24px'
  }
};

function addPerson(props, chatId, userName, callback) {
  axios.post(getApiUrl(props) + "/chats/" + chatId + "/people/", {
    username: userName
  }, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('New Person Error', error);
  });
}

function removePerson(props, chatId, userName, callback) {
  axios.put(getApiUrl(props) + "/chats/" + chatId + "/people/", {
    username: userName
  }, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Delete Person Error', error);
  });
}

function getOtherPeople(props, chatId, successCallback, errorCallback) {
  axios.get(getApiUrl(props) + "/chats/" + chatId + "/others/", {
    headers: getHeaders(props)
  }).then(function (response) {
    props.onGetOtherPeople && props.onGetOtherPeople(chatId, response.data);
    successCallback && successCallback(chatId, response.data);
  })["catch"](function (error) {
    console.log('Fetch Other People Error', error);
    errorCallback && errorCallback();
  });
}

function getMyData(props, callback) {
  axios.get(getApiUrl(props) + "/chats/me/", {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Get Myself Error', error);
  });
}

function editMyData(props, data, callback) {
  axios.patch(getApiUrl(props) + "/chats/me/", data, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Edit Myself Error', error);
  });
}

function leaveChat(props, chatId, callback) {
  axios["delete"](getApiUrl(props) + "/chats/" + chatId + "/people/", {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {
    console.log('Delete Person Error', error);
  });
}

function isTyping(props, chatId, callback) {
  axios.post(getApiUrl(props) + "/chats/" + chatId + "/typing/", {}, {
    headers: getHeaders(props)
  }).then(function (response) {
    callback && callback(response.data);
  })["catch"](function (error) {});
}

export { AutoComplete as AutoCompleteInput, Avatar, Button, ChatCard, ChatEngineApp as ChatEngine, ChatEngineContext, ChatEngineWrapper, ChatFeed, ChatHeader, ChatList, ChatSettings, ChatSettingsTop, ChatSocket, Dot, Message$1 as MessageBubble, NewChatForm, NewMessageForm$1 as NewMessageForm, OptionsSettings, PeopleSettings, PhotosSettings, Socket, TextInput, Typers, addPerson, deleteChat, deleteMessage, editChat, editMessage, editMyData, getChat, getChats, getLatestChats, getLatestMessages, getMessage, getMessages, getMyData, getOrCreateChat, getOtherPeople, isTyping, leaveChat, newChat, readMessage, removePerson, sendMessage };
//# sourceMappingURL=index.modern.js.map
